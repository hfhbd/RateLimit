public abstract interface class app/softwork/ratelimit/DatabaseStorage : app/softwork/ratelimit/Storage {
	public abstract fun getTimeSource ()Lapp/softwork/ratelimit/DatabaseStorage$DatabaseTimeSource;
}

public final class app/softwork/ratelimit/DatabaseStorage$DatabaseTimeSource : kotlin/time/AbstractLongTimeSource {
	public static final field INSTANCE Lapp/softwork/ratelimit/DatabaseStorage$DatabaseTimeSource;
	public final fun getDurationUnit ()Ljava/util/concurrent/TimeUnit;
	public fun markNow ()Lkotlin/time/TimeMark;
	public fun read ()J
}

public final class app/softwork/ratelimit/DatabaseStorage$DatabaseTimeSource$DatabaseTimeMark : kotlin/time/TimeMark {
	public fun <init> (J)V
	public fun elapsedNow-UwyO8pc ()J
	public final fun getMark ()J
}

public final class app/softwork/ratelimit/DatabaseStorage$DefaultImpls {
	public static fun getTimeSource (Lapp/softwork/ratelimit/DatabaseStorage;)Lapp/softwork/ratelimit/DatabaseStorage$DatabaseTimeSource;
}

public final class app/softwork/ratelimit/InMemory : app/softwork/ratelimit/Storage {
	public fun <init> ()V
	public fun getOrNull (Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	public fun getTimeSource ()Lkotlin/time/TimeSource;
	public fun remove (Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	public fun set (Ljava/lang/String;Lapp/softwork/ratelimit/Storage$Requested;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
}

public final class app/softwork/ratelimit/RateLimit {
	public static final field Feature Lapp/softwork/ratelimit/RateLimit$Feature;
	public fun <init> (Lapp/softwork/ratelimit/RateLimit$Configuration;)V
	public final fun getConfiguration ()Lapp/softwork/ratelimit/RateLimit$Configuration;
	public final fun isAllowed (Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
}

public final class app/softwork/ratelimit/RateLimit$Configuration {
	public fun <init> ()V
	public final fun alwaysAllow (Lkotlin/jvm/functions/Function1;)V
	public final fun alwaysBlock (Lkotlin/jvm/functions/Function1;)V
	public final fun getAlwaysAllow ()Lkotlin/jvm/functions/Function1;
	public final fun getAlwaysBlock ()Lkotlin/jvm/functions/Function1;
	public final fun getHost ()Lkotlin/jvm/functions/Function1;
	public final fun getLimit ()I
	public final fun getSendRetryAfterHeader ()Z
	public final fun getSkip ()Lkotlin/jvm/functions/Function1;
	public final fun getStorage ()Lapp/softwork/ratelimit/Storage;
	public final fun getTimeout-UwyO8pc ()J
	public final fun host (Lkotlin/jvm/functions/Function1;)V
	public final fun setAlwaysAllow (Lkotlin/jvm/functions/Function1;)V
	public final fun setAlwaysBlock (Lkotlin/jvm/functions/Function1;)V
	public final fun setHost (Lkotlin/jvm/functions/Function1;)V
	public final fun setLimit (I)V
	public final fun setSendRetryAfterHeader (Z)V
	public final fun setSkip (Lkotlin/jvm/functions/Function1;)V
	public final fun setStorage (Lapp/softwork/ratelimit/Storage;)V
	public final fun setTimeout-LRDsOJo (J)V
	public final fun skip (Lkotlin/jvm/functions/Function1;)V
}

public final class app/softwork/ratelimit/RateLimit$Feature : io/ktor/application/ApplicationFeature {
	public fun getKey ()Lio/ktor/util/AttributeKey;
	public fun install (Lio/ktor/application/Application;Lkotlin/jvm/functions/Function1;)Lapp/softwork/ratelimit/RateLimit;
	public synthetic fun install (Lio/ktor/util/pipeline/Pipeline;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
}

public abstract class app/softwork/ratelimit/RateLimit$RequestResult {
}

public final class app/softwork/ratelimit/RateLimit$RequestResult$Allow : app/softwork/ratelimit/RateLimit$RequestResult {
	public static final field INSTANCE Lapp/softwork/ratelimit/RateLimit$RequestResult$Allow;
}

public final class app/softwork/ratelimit/RateLimit$RequestResult$Block : app/softwork/ratelimit/RateLimit$RequestResult {
	public synthetic fun <init> (JLkotlin/jvm/internal/DefaultConstructorMarker;)V
	public final fun component1-UwyO8pc ()J
	public final fun copy-LRDsOJo (J)Lapp/softwork/ratelimit/RateLimit$RequestResult$Block;
	public static synthetic fun copy-LRDsOJo$default (Lapp/softwork/ratelimit/RateLimit$RequestResult$Block;JILjava/lang/Object;)Lapp/softwork/ratelimit/RateLimit$RequestResult$Block;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getRetryAfter-UwyO8pc ()J
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

public abstract interface class app/softwork/ratelimit/Storage {
	public abstract fun getOrNull (Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	public abstract fun getTimeSource ()Lkotlin/time/TimeSource;
	public abstract fun remove (Ljava/lang/String;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
	public abstract fun set (Ljava/lang/String;Lapp/softwork/ratelimit/Storage$Requested;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
}

public final class app/softwork/ratelimit/Storage$Requested {
	public fun <init> (ILkotlin/time/TimeMark;)V
	public final fun component1 ()I
	public final fun component2 ()Lkotlin/time/TimeMark;
	public final fun copy (ILkotlin/time/TimeMark;)Lapp/softwork/ratelimit/Storage$Requested;
	public static synthetic fun copy$default (Lapp/softwork/ratelimit/Storage$Requested;ILkotlin/time/TimeMark;ILjava/lang/Object;)Lapp/softwork/ratelimit/Storage$Requested;
	public fun equals (Ljava/lang/Object;)Z
	public final fun getLastRequest ()Lkotlin/time/TimeMark;
	public final fun getTrial ()I
	public fun hashCode ()I
	public fun toString ()Ljava/lang/String;
}

